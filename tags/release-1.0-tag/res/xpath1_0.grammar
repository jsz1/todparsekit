//[1]        LocationPath                        ::=       RelativeLocationPath | AbsoluteLocationPath
locationPath = relativeLocationPath | absoluteLocationPath;


//[2]        AbsoluteLocationPath                ::=       '/' RelativeLocationPath? | AbbreviatedAbsoluteLocationPath    
absoluteLocationPath = '/' relativeLocationPath? | abbreviatedAbsoluteLocationPath;


//[3] RelativeLocationPath ::= Step    | RelativeLocationPath '/' Step    | AbbreviatedRelativeLocationPath
// avoiding left recursion by changing to this
//[3] RelativeLocationPath ::= Step SlashStep*    | AbbreviatedRelativeLocationPath
relativeLocationPath = step slashStep* | abbreviatedRelativeLocationPath;


// [4] Step ::=       AxisSpecifier NodeTest Predicate* | AbbreviatedStep    
step = axisSpecifier nodeTest predicate* | abbreviatedStep;


// [5]    AxisSpecifier ::= AxisName '::' | AbbreviatedAxisSpecifier
axisSpecifier = axisName '::' | abbreviatedAxisSpecifier;


// [6] AxisName ::= 'ancestor' | 'ancestor-or-self' | 'attribute' | 'child' | 'descendant' | 'descendant-or-self'
//            | 'following' | 'following-sibling' | 'namespace' | 'parent' | 'preceding' | 'preceding-sibling' | 'self'
axisName = 'ancestor' | 'ancestor-or-self' | 'attribute' | 'child' | 'descendant' | 'descendant-or-self'
            | 'following' | 'following-sibling' | 'namespace' | 'parent' | 'preceding' | 'preceding-sibling' | 'self';


// [7]  NodeTest ::= NameTest | NodeType '(' ')' | 'processing-instruction' '(' Literal ')'
nodeTest = nameTest | nodeType '(' ')' | 'processing-instruction' '(' literal ')';


// [8]  Predicate ::=  '[' PredicateExpr ']'
predicate = '[' predicateExpr ']';


// [9]  PredicateExpr    ::=       Expr
predicateExpr = expr;


// [10]  AbbreviatedAbsoluteLocationPath ::= '//' RelativeLocationPath    
abbreviatedAbsoluteLocationPath = '//' relativeLocationPath;

// [11] AbbreviatedRelativeLocationPath ::= RelativeLocationPath '//' Step    
abbreviatedRelativeLocationPath = relativeLocationPath '//' step;

// [12] AbbreviatedStep    ::=       '.'    | '..'
AbbreviatedStep = '.' | '..';

// [13] AbbreviatedAxisSpecifier ::=       '@'?
abbreviatedAxisSpecifier = '@'?;


// [14]       Expr ::=       OrExpr    
expr = orExpr;


// [15] PrimaryExpr    ::=  VariableReference    
//                    | '(' Expr ')'    
//                    | Literal    
//                    | Number    
//                    | FunctionCall
primaryExpr = variableReference | '(' expr ')' | Word | Num | functionCall



// [16] FunctionCall ::= FunctionName '(' ( Argument ( ',' Argument )* )? ')'    

// commaArg ::= ',' Argument
// [16] FunctionCall ::= FunctionName '(' ( Argument commaArg* )? ')'    

commaArg = ',' argument;
functionCall ::= functionName '(' (argument commaArg*)? ')'    


// [17] Argument ::=       Expr
argument = expr;


// [18]  UnionExpr ::=       PathExpr | UnionExpr '|' PathExpr    
unionExpr = pathExpr | unionExpr '|' pathExpr;



// pipePathExpr :: = | PathExpr
// [18]  UnionExpr ::=       PathExpr PipePathExpr*

pipePathExpr = | pathExpr;
unionExpr = pathExpr pipePathExpr*;



//[19]       PathExpr ::= LocationPath    
//                    | FilterExpr    
//                    | FilterExpr '/' RelativeLocationPath    
//                    | FilterExpr '//' RelativeLocationPath    
pathExpr = locationPath | filterExpr | filterExpr '/' relativeLocationPath | filterExpr '//' relativeLocationPath;


#pragma mark Left Recursion????????????
// [20]  FilterExpr     ::=       PrimaryExpr    | FilterExpr Predicate
// [20]  FilterExpr     ::=       PrimaryExpr Predicate?

filterExpr = primaryExpr predicate?


// #pragma mark Left Recursion
// [21] OrExpr ::= AndExpr    | OrExpr 'or' AndExpr
// orAndExpr ::= 'or' AndExpr
// me: AndExpr orAndExpr*

orExpr = andExpr orAndExpr*;
orAndExpr = 'or' AndExpr;



// #pragma mark Left Recursion
// [22] AndExpr ::= EqualityExpr | AndExpr 'and' EqualityExpr    
// andEqualityExpr
// EqualityExpr andEqualityExpr

andEqualityExpr = 'and' equalityExpr;
andExpr = equalityExpr andEqualityExpr;




#pragma mark Left Recursion
// [23] EqualityExpr ::= RelationalExpr    
//            | EqualityExpr '=' RelationalExpr
//            | EqualityExpr '!=' RelationalExpr    

// RelationalExpr (equalsRelationalExpr | notEqualsRelationalExpr)?






#pragma mark Left Recursion

// [24] RelationalExpr ::= AdditiveExpr
//                        | RelationalExpr '<' AdditiveExpr    
//                        | RelationalExpr '>' AdditiveExpr    
//                        | RelationalExpr '<=' AdditiveExpr    
//                        | RelationalExpr '>=' AdditiveExpr

// RelationalExpr = AdditiveExpr (ltAdditiveExpr | gtAdditiveExpr | lteAdditiveExpr | gteAdditiveExpr)?



#pragma mark Left Recursion

// [25] AdditiveExpr ::= MultiplicativeExpr    
//                        | AdditiveExpr '+' MultiplicativeExpr    
//                        | AdditiveExpr '-' MultiplicativeExpr    

// AdditiveExpr ::= MultiplicativeExpr (plusMultiplicativeExpr | minusMultiplicativeExpr)?



#pragma mark Left Recursion

// [26] MultiplicativeExpr ::= UnaryExpr    
//                            | MultiplicativeExpr MultiplyOperator UnaryExpr    
//                            | MultiplicativeExpr 'div' UnaryExpr    
//                            | MultiplicativeExpr 'mod' UnaryExpr

// MultiplicativeExpr :: = UnaryExpr (multiplyUnaryExpr | divUnaryExpr | modUnaryExpr)? 



#pragma mark Left Recursion

// [27] UnaryExpr ::= UnionExpr | '-' UnaryExpr

// UnaryExpr ::= '-'? UnionExpr

// [28] ExprToken ::= '(' | ')' | '[' | ']' | '.' | '..' | '@' | ',' | '::'
//                    | NameTest    
//                    | NodeType    
//                    | Operator    
//                    | FunctionName    
//                    | AxisName    
//                    | Literal    
//                    | Number    
//                    | VariableReference    


// [32] Operator ::= OperatorName    
//                    | MultiplyOperator    
//                    | '/' | '//' | '|' | '+' | '-' | '=' | '!=' | '<' | '<=' | '>' | '>='    


// [33] OperatorName ::=       'and' | 'or' | 'mod' | 'div'    

// [34]       MultiplyOperator                    ::=       '*'    


//[7]       QName       ::=   PrefixedName| UnprefixedName
//[8]       PrefixedName ::=        Prefix ':' LocalPart
//[9]       UnprefixedName     ::=        LocalPart
//[10]       Prefix       ::=       NCName
//[11]       LocalPart       ::=       NCName


// [35] FunctionName ::= QName - NodeType    

// [36]  VariableReference ::=       '$' QName    


// [37] NameTest ::= '*' | NCName ':' '*' | QName    


// [38] NodeType ::= 'comment'    
//                    | 'text'    
//                    | 'processing-instruction'    
//                    | 'node'
