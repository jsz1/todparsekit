
@reportsWhitespaceTokens = YES;

@symbols = '&#' '&#x' '</' '/>' '<![' '<?xml' '<!DOCTYPE' '<!ELEMENT' '<!ATTLIST' '#PCDATA' '#REQUIRED' '#IMPLIED' '#FIXED' ')*';

@delimitState = '<';

@delimitedStrings = '<!--' '-->' nil 
                    '<?' '?>' nil
                    '<![CDATA[' ']]>' nil;

@start = document;
document = prolog element misc*;

@wordState = ':' '.' '-' '_';
@wordChars = ':' '.' '-' '_';
name = /[^-:\.]\w+/;

nmtoken = Word;

entityValue = QuotedString;
attValue = QuotedString;
systemLiteral = QuotedString;
pubidLiteral = QuotedString;


charData = /[^<\&]+/; # TODO why does this need to escape the amp ?

comment = DelimitedString('<!--', '-->');

pi = DelimitedString('<?', '?>');

cdSect = DelimitedString('<![CDATA[', ']]>');

prolog = xmlDecl? misc* (doctypedecl misc*)?;

xmlDecl = '<?xml' versionInfo encodingDecl? sdDecl? S? '?>';

versionInfo = S 'version' eq QuotedString; #TODO

eq = S? '=' S?;

misc = comment | pi | S;

doctypedecl = '<!DOCTYPE' S name (S externaID)? S? ('[' intSubset ']' S?)? '>';

declSep = peReference | S;

intSubset = (markupdecl | declSep)*;

markupdecl = elementdecl | attlistDecl | entityDecl | notationDecl | pi | comment;

sdDecl = S 'standalone' eq QuotedString; # /(["'])(yes|no)\1/; # TODO

element = emptyElemTag | sTag content eTag;

sTag = '<' name (S attribute)* S? '>';

attribute = name eq attValue;

eTag = '</' name S? '>';

content = Empty | (element | reference | cdSect | pi | comment | charData)+;

emptyElemTag = '<' name (S attribute)* S? '/>';

elementdecl = '<!ELEMENT' S name S contentspec S? '>';

contentspec = 'EMPTY' | 'ANY' | mixed | children;

children = (choice | seq) ('?' | '*' | '+')?;

cp = (name) ('?' | '*' | '+')?; # TODO !!!!!!!!!!!!!!

choice = '(' S? cp ( S? '|' S? cp )+ S? ')';

seq = '(' S? cp ( S? ',' S? cp )* S? ')';

mixed = '(' S? '#PCDATA' (S? '|' S? name)* S? ')*' | '(' S? '#PCDATA' S? ')';

attlistDecl    = '<!ATTLIST' S name attDef* S? '>';

attDef = S name S attType S defaultDecl;

attType = stringType | tokenizedType | enumeratedType;

stringType = 'CDATA';

tokenizedType = 'ID' | 'IDREF' | 'IDREFS' | 'ENTITY' | 'ENTITIES' | 'NMTOKEN' | 'NMTOKENS';

enumeratedType = notationType | enumeration;

notationType = 'NOTATION' S '(' S? name (S? '|' S? name)* S? ')';

enumeration    = '(' S? nmtoken (S? '|' S? nmtoken)* S? ')';

defaultDecl = '#REQUIRED' | '#IMPLIED' | (('#FIXED' S)? attValue);

charRef = '&#' /[0-9]+/ ';' | '&#x' /[0-9a-fA-F]+/ ';';

reference = entityRef | charRef;

entityRef = '&' name ';';

peReference = '%' name ';';

entityDecl = geDecl | peDecl;

geDecl = '<!ENTITY' S name S entityDef S? '>';

peDecl = '<!ENTITY' S '%' S name S peDef S? '>';

entityDef = entityValue | (externalID nDataDecl?);

peDef = entityValue | externalID;

externalID = 'SYSTEM' S systemLiteral | 'PUBLIC' S pubidLiteral S systemLiteral;

nDataDecl = S 'NDATA' S name;

encodingDecl = S 'encoding' eq QuotedString; # TODO

notationDecl = '<!NOTATION' S name S (externalID | publicID) S? '>';

publicID = 'PUBLIC' S pubidLiteral;
