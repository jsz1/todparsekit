<html>
<head>
	<title>TDParseKit README</title>
	<style>
		.code {border:1px solid silver; background:#eee; padding:5px 10px; margin:5px;}
	</style>
</head>
<body>
<h1>TDParseKit</h1>

<h2>About</h2>
<p>TDParseKit is a Mac OS X Framework written by Todd Ditchendorf in Objective-C 2.0 and released under the MIT Open Source License. The framework is an Objective-C port of the tools described in <a href="http://www.amazon.com/Building-Parsers-Java-Steven-Metsker/dp/0201719622" title="Amazon.com: Building Parsers With Java(TM): Steven John Metsker: Books">"Building Parsers with Java" by Steven John Metsker</a>. Some changes have been made to the designs in the book to match common Cocoa/Objective-C design patterns and conventions. However, the changes are relatively superficial, and the book is the best documentation available for this framework.</p>


<h2>Xcode Project</h2>
<p>The Xcode project containing this framework consists of 4 targets:</p>

<ol>
<li><b>Framework</b> : the TDParseKit Framework.</li>
<li><b>Tests</b> : a UnitTest Bundle containing many unit tests (actually, more correctly, interaction tests) for the framework as well as some example classes that serve as real-world usages of the framework.</li>
<li><b>DemoApp</b> : A simple Cocoa demo app that gives a visual presentation of the results of tokenizing text using the TDTokenizer class.</li>
<li><b>DebugApp</b> : A simple Cocoa app that exists only to run arbitrary test code thru GDB with breakpoints for debugging (I was not able to do that with the UnitTest bundle.).</li>
</ol>

<h2>TDParseKit Framework</h2>

<p>Classes in the TDParseKit Framework offer 2 basic services of general use to Cocoa developers:</p>

<ol>
<li><b>Tokenization</b> via a tokenizer class</li>
<li><b>Parsing</b> via a hi-level parser-building toolkit</li>
</ol>

<hr/>
<h3>Tokenization</h3>

<p>The API for tokenization is provided by the <tt>TDTokenizer</tt> class. Cocoa developers will be familiar with the <tt>NSScanner</tt> class provided by the Foundation Framework which provides a similar service. However, the <tt>TDTokenizer</tt> class is much simpler, yet more configurable, flexible, and powerful.</p>

<p>Example usage:</p>

<div class="code">
<pre>
NSString *s = @"\"It's 123 blast-off!\", she said, // watch out!\n"
              @"and &lt;= 3.5 'ticks' later /* wince */, it's blast-off!";
TDTokenizer *t = [TDTokenizer tokenizerWithString:s];

TDToken *eof = [TDToken EOFToken];
TDToken *tok = nil;

while ((tok = [t nextToken]) != eof) {
    NSLog(@" (%@)", tok.stringValue);
}
</pre>
</div>

<p>outputs:</p>
<div class="code">
<pre> ("It's 123 blast-off!")
 (,)
 (she)
 (said)
 (,)
 (and)
 (&lt;=)
 (3.5)
 ('ticks')
 (later)
 (,)
 (it's)
 (blast-off)
 (!)
</pre>
</div>

<p>Each token produced is an object of class <tt>TDToken</tt>. <tt>TDToken</tt>s have a <tt>tokenType</tt> (<tt>Word</tt>, <tt>Symbol</tt>, <tt>Num</tt>, <tt>QuotedString</tt>, etc.) and both a <tt>stringValue</tt> and a <tt>floatValue</tt>.</p>


<p>As you can see from the output, <tt>TDTokenzier</tt> is configured by default to handle several common parsing tasks:</p>
<ul>
<li>C- and C++-style comments</li>
<li>single- and double-quoted string tokens</li>
<li>common multiple character symbols (<tt>&lt;=</tt>)</li>
<li>apostrophes, dashes and other symbol chars that should not signal the start of a new Symbol token, but rather be included in the current Word or Num token (<tt>it's</tt>, <tt>blast-off</tt>, <tt>3.5</tt>)</li>	
</ul>


<p>All of those features are configurable. TDTokenizer may be configured to:</p>

<ul>

<li>recognize more (or fewer) multi-char symbols. ex: <div class="code"><pre>[t.symbolState add:@"!="];</pre></div>
<p><small>allows <tt>!=</tt> to be recognized as a single <tt>Symbol</tt> token rather than two adjacent <tt>Symbol</tt> tokens</small></p>
</li>

<li>add new internal symbol chars to be included in the current <tt>Word</tt> token OR recognize internal symbols like apostrophe and dash to actually signal a new <tt>Symbol</tt> token rather than being part of the current Word token. ex: 
	<div class="code"><pre>[t.wordState setWordChar:'_'];</pre></div>
<p><small>allows Word tokens to contain internal underscores</small></p>	
</li>
	
	
<li>change which chars singnal the start of a token of any given type. ex: <div class="code"><pre>[t setCharacterState:t.wordState from:'_' to:'_'];</pre></div>
<p><small>allows Word tokens to start with underscore</small></p>
</li>

<li>turn off recognition of "slash-slash" (//) comments.ex: 
<div class="code"><pre>[t setCharacterState:t.symbolState from:'/' to:'/'];</pre></div>
<p><small>slash chars now produce a Symbol token rather than causing the tokenizer to strip text until the next newline char or begin striping for a multiline comment if appropriate (<tt>/*</tt>)</small></p>
</li>
</ul>

<hr/>
<h3>Parsing</h3>

<p>TDParseKit also includes a collection of token parser subclasses (of the abstract <tt>TDParser</tt> class) including collection parsers such as <tt>TDAlternation</tt>, <tt>TDSequence</tt>, and <tt>TDRepetition</tt> as well as terminal parsers including <tt>TDWord</tt>, <tt>TDNum</tt>, <tt>TDSymbol</tt>, <tt>TDQuotedString</tt>, etc. Also included are parser subclasses which work in individual chars such as <tt>TDChar</tt>, <tt>TDDigit</tt>, and <tt>TDSpecificChar</tt>. These char parsers are useful for things like RegEx parsing. Generally speaking though, the token parsers will be more useful and interesting.</p>

<p>The parser classes represent a <b>Composite</b> pattern. Programs can build a composite parser, in <b>Objective-C</b> (rather than a separate language like with lex&amp;yacc), from a collection of terminal parsers composed into alternations, sequences, and repetitions to represent an infinite number of languages.</p>

<p>Parsers built from TDParseKit are <b>non-deterministic, recursive descent parsers</b>, which basically means they trade some performance for ease of user programming and simplicity of implementation.</p>

<p>Here is an example of how one might build a parser for a simple voice-search command language (note: TDParseKit does not include any kind of speech recognition technology). The language consists of:</p>

<div class="code">
<pre>search google for? &lt;search-term&gt;</pre>
</div>

<div class="code">
<pre>
...

	[self parseString:@"search google 'iphone'"];
...
	
- (void)parseString:(NSString *)s {
	TDSequence *parser = [TDSequence sequence];

	[parser add:[[TDLiteral literalWithString:@"search"] discard]];
	[parser add:[[TDLiteral literalWithString:@"google"] discard]];

	TDAlternation *optionalFor = [TDAlternation alternation];
	[optionalFor add:[TDEmpty empty]];
	[optionalFor add:[TDLiteral literalWithString:@"for"]];

	[parser add:[optionalFor discard]];

	TDParser *searchTerm = [TDQuotedString quotedString];
	[searchTerm setAssembler:self selector:@selector(workOnSearchTermAssembly:)];
	[parser add:searchTerm];

	TDAssembly *result = [parser bestMatchFor:[TDTokenAssembly assmeblyWithString:s]];
	
	NSLog(@" %@", result);

	// output:
	//  ['iphone']search/google/'iphone'^
}

...

- (void)workOnSearchTermAssembly:(TDAssembly *)a {
	TDToken *t = [a pop]; // a QuotedString token with a stringValue of 'iphone'
	[self doGoogleSearchForTerm:t.stringValue];
}

</pre>
</div>


</body>
</html>