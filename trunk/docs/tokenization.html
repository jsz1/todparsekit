<html>
<head>
	<title>TDParseKit Tokenization</title>
	<style>
		h1 {position:fixed; left:0; top:0; right:0; margin:0; border-bottom:1px solid silver; padding:3px 10px; background:#eeeeec; font:bold 16px "Lucida Grande";}
		#content {width:575px; margin:60px auto 30px; text-align:justify;}
		body, html {margin:0; padding:0; font:14px/1.5 "Lucida Grande", Helvetica, Verdana;}
		tt, pre {font:12px Monaco;}
		table {border:1px solid silver; background:#eeeeff; margin:25px 5px;}
		th, td {border:1px solid silver;}
		.code {border:2px solid silver; background:#eee; padding:5px 10px; margin:25px 5px;}
		h3 {border-bottom:1px solid silver; padding:3px; background:#eeeeff;}
		a[name] {display:block; margin-bottom:60px;}
	</style>
</head>
<body>
	<h1>TDParseKit Documentation</h1>
<div id="content">
		
	<h2>Tokenization</h2>
	
	<ul>
		<li><a href="#basic-usage">Basic Usage of <tt>TDTokenizer</tt></a></li>
		<li><a href="#default-behavior">Default Behavior of <tt>TDTokenizer</tt></a></li>
		<li><a href="#custom-behavior">Customizing <tt>TDTokenizer</tt> behavior</a></li>
	</ul>

<a name="basic-usage"></a>
<h3>Basic Usage of <tt>TDTokenizer</tt></h3>

<p><b>TDParseKit</b> provides general-purpose string tokenization services through the <tt><b>TDTokenizer</b></tt> and <tt><b>TDToken</b></tt> classes. Cocoa developers will be familiar with the <tt><b>NSScanner</b></tt> class provided by the Foundation Framework which provides a similar service. However, the <tt>TDTokenizer</tt> class is much easier to use for many common tokenization tasks, and offers powerful configuration options if the default tokenization behavior doesn't match your needs.</p>

<table border="1" cellpadding="5" cellspacing="0">
	<tr>
		<th><tt><b>TDTokenizer</b></tt></th>
	</tr>
	<tr>
		<td>
			<p>
			<tt>+ (id)tokenizerWithString:(NSString *)s;</tt><br/>
			</p>
			<p>
				<tt>- (TDToken *)nextToken;</tt><br/>
				<tt>...</tt><br/>
			</p>
		</td>
	</tr>
</table>

<p>To use <tt>TDTokenizer</tt>, create an instance with an <tt>NSString</tt> object and retrieve a series of <tt>TDToken</tt> objects as you repeatedly call the <tt>-nextToken</tt> method. The <tt>EOFToken</tt> singleton signals the end.</p>

<div class="code">
<pre>
NSString *s = @"2 != -47. /* comment */ Blast-off!! 'Woo-hoo!' // comment";
TDTokenizer *t = [TDTokenizer tokenizerWithString:s];

TDToken *eof = [TDToken EOFToken];
TDToken *tok = nil;

while ((tok = [t nextToken]) != eof) {
    NSLog(@"(%@) (%.1f) : %@", 
        tok.stringValue, tok.floatValue, [tok debugDescription]);
}
</pre>
</div>

<p>Outputs:</p>

<div class="code">
<pre>
(2) (2.0) : &lt;Number &laquo;2&raquo;>
(!=) (0.0) : &lt;Symbol &laquo;!=&raquo;>
(-47) (-47.0) : &lt;Number &laquo;-47&raquo;>
(.) (0.0) : &lt;Symbol &laquo;.&raquo;>
(Blast-off) (0.0) : &lt;Word &laquo;Blast-off&raquo;>
(!) (0.0) : &lt;Symbol &laquo;!&raquo;>
(!) (0.0) : &lt;Symbol &laquo;!&raquo;>
('Woo-hoo!') (0.0) : &lt;Quoted String &laquo;'Woo-hoo!'&raquo;>
</pre>
</div>

<p>Each <tt>TDToken</tt> object returned has a <tt>stringValue</tt>, a <tt>floatValue</tt> and a <tt>tokenType</tt>. The <tt>tokenType</tt> is and enum value type called <tt>TDTokenType</tt> with possible values of <tt>TDTT_NUMBER</tt>, <tt>TDTT_QUOTED</tt>, <tt>TDTT_SYMBOL</tt> or <tt>TDTT_WORD</tt>. <tt>TDTokens</tt> also have corresponding <tt>BOOL</tt> properties for convenience: <tt>isNumber</tt>, <tt>isQuotedString</tt>, <tt>isSymbol</tt> and <tt>isWord</tt>.</p>

<table border="1" cellpadding="5" cellspacing="0">
	<tr>
		<th><tt><b>TDToken</b></tt></th>
	</tr>
	<tr>
		<td>
			<p>
				<tt>+ (TDToken *)EOFToken;</tt><br/>
			</p>
			<p>
				<tt>@property (readonly) TDTokenType tokenType;</tt><br/>
				<tt>@property (readonly) CGFloat floatValue;</tt><br/>
				<tt>@property (readonly, copy) NSString *stringValue;</tt><br/>
			</p>
			<p>
				<tt>@property (readonly) BOOL isNumber;</tt><br/>
				<tt>@property (readonly) BOOL isSymbol;</tt><br/>
				<tt>@property (readonly) BOOL isWord;</tt><br/>
				<tt>@property (readonly) BOOL isQuotedString;</tt><br/>
			</p>
			<p>
				<tt>...</tt><br/>
			</p>
		</td>
	</tr>
</table>

<a name="default-behavior"></a>
<h3>Default Behavior of <tt>TDTokenizer</tt></h3>

<p>Let's examine the default behavior of <tt>TDTokenizer</tt> for each token type.</p>

<h4>Number</h4>

<p>Sequences of digits (<tt>&laquo;2&raquo;</tt> <tt>&laquo;47&raquo;</tt>) are recognized as <tt>Number</tt> tokens. Floating point numbers (<tt>&laquo;47.5&raquo;</tt>) are recognized as single <tt>Number</tt> tokens as you'd expect (rather than two <tt>Number</tt> tokens separated by a <tt>&laquo;.&raquo;</tt> <tt>Symbol</tt> token). By default, <tt>TDTokenizer</tt> will recognize a <tt>&laquo;-&raquo;</tt> symbol followed immediately by digits (<tt>&laquo;-47&raquo;</tt>) as a number token with a negative value. However, <tt>&laquo;+&raquo;</tt> characters are always seen as the beginning of a <tt>Symbol</tt> token by default, even when followed immediately by digits, so "explicitly-positive" <tt>Number</tt> tokens are not supported by default (see below for an example of how to configure <tt>TDTokenizer</tt> to support numbers starting with an explicit <tt>&laquo;+&raquo;</tt> character).</p>
	
<h4>Symbol</h4>
	
<p>Most symbol characters (<tt>&laquo;.&raquo;</tt> <tt>&laquo;!&raquo;</tt>) are recognized as single-character <tt>Symbol</tt> tokens (even when sequencial such as <tt>&laquo;!&raquo;&laquo;!&raquo;</tt>). However, notice that <tt>TDTokenizer</tt> recognizes common multi-character symbols (<tt>&laquo;!=&raquo;</tt>) as a single <tt>Symbol</tt> token by default. In fact, <tt>TDTokenizer</tt> can be configured to recognize any given string as a multi-character symbol, or it can be configured to always recognize each symbol character as a separate <tt>Symbol</tt> token (no mulit-character symbols). The default multi-character symbols recognized by <tt>TDTokenizer</tt> are: <tt>&laquo;&lt;=&raquo;</tt>, <tt>&laquo;&gt;=&raquo;</tt>, <tt>&laquo;:=&raquo;</tt>, <tt>&laquo;!=&raquo;</tt>, <tt>&laquo;==&raquo;</tt>, <tt>&laquo;&lt;&gt;&raquo;</tt>.</p>

<p>By default, <tt>TDTokenizer</tt> recognizes C-style (<tt>//</tt>) and C++-style (<tt>/* */</tt>) comments and removes the associated comments from the output rather than producing tokens. See below for steps to turn off comments recognition.</p>


<h4>Word</h4>
<p><tt>&laquo;Blast-off&raquo;</tt> is recognized as a single <tt>Word</tt> token despite containing a symbol character (<tt>&laquo;-&raquo;</tt>) that would normally signal the start of a new <tt>Symbol</tt> token. By default, <tt>TDTokenzier</tt> allows <tt>Word</tt> tokens to <b>contain</b> (but <b>not start with</b>) several symbol and number characters: <tt>&laquo;-&raquo;</tt>, <tt>&laquo;_&raquo;</tt>, <tt>&laquo;'&raquo;</tt>, <tt>&laquo;0&raquo;</tt>-<tt>&laquo;9&raquo;</tt>. The consequence of this behavior is that <tt>TDTokenizer</tt> will recognize the follwing strings as individual <tt>Word</tt> tokens by default: <tt>&laquo;it's&raquo;</tt>, <tt>&laquo;first_name&raquo;</tt>, <tt>&laquo;sat-yr-9&raquo;</tt> <tt>&laquo;Rodham-Clinton&raquo;</tt>. Again, you can configure <tt>TDTokenizer</tt> to alter this default behavior.</p>

<h4>Quoted String</h4>
<p><tt>TDTokenizer</tt> produces <tt>Quoted String</tt> tokens for substrings enclosed in quote delimiter characters. The default delimiters are single- or double-quotes (<tt>&laquo;'&raquo;</tt> or <tt>&laquo;"&raquo;</tt>). The delimiter characters are configurable (see below). Note that the <tt>stringValue</tt> of <tt>Quoted String</tt> tokens include the quote delimiter characters (&laquo;'Woo-hoo!'&raquo;).</p>


<h4>Whitespace</h4>
<p>By default, whitespace characters are silently consumed by <tt>TDTokenizer</tt>, and <tt>Whitespace</tt> tokens are never emitted. However, you can configure which characters are considered <tt>Whitespace</tt> characters or even ask <tt>TDTokenizer</tt> to return <tt>Whitespace</tt> tokens containing the literal whitespace <tt>stringValue</tt>s.</p>


<a name="custom-behavior"></a>
<h3>Customizing <tt>TDTokenizer</tt> behavior</h3>

<p>There are two basic types of decisions <tt>TDTokenizer</tt> must make when tokenizing strings:</p>

<ol>
	<li>Which token type should be created for a given start character?</li>
	<li>Which characters are allowed within the current token being created?</li>
</ol>

<p><tt>TDTokenizer</tt>'s behavior with respect to these two types of decisions is totally configurable. Let's tackle them, starting with the second question first.</p>



<h4>Changing which characters are allowed within a token of a particular type</h4>

<p>Once <tt>TDTokenizer</tt> has decided which token type to create for a given start character (see below), it temporarily passes control to one of its "state" helper objects to finish consumption of characters for the current token. Therefore, the logic for deciding which characters are allowed within a token of a given type is controlled by the "state" objects which are instances of subclasses of the <tt>TDTokenizerState</tt> class: <tt>TDNumberState</tt>, <tt>TDSymbolState</tt>, <tt>TDSlashState</tt>, <tt>TDWordState</tt>, and <tt>TDQuoteState</tt>. The state objects are accessible via properties of the <tt>TDTokenizer</tt> object.</p>

<table border="1" cellpadding="5" cellspacing="0">
	<tr>
		<th><tt><b>TDTokenizer</b></tt></th>
	</tr>
	<tr>
		<td>
			<p>
				<tt>...</tt><br/>
				<tt>@property (readonly, retain) TDWhitespaceState *whitespaceState;</tt><br/>
				<tt>@property (readonly, retain) TDNumberState *numberState;</tt><br/>
				<tt>@property (readonly, retain) TDQuoteState *quoteState;</tt><br/>
				<tt>@property (readonly, retain) TDSlashState *slashState;</tt><br/>
				<tt>@property (readonly, retain) TDSymbolState *symbolState;</tt><br/>
				<tt>@property (readonly, retain) TDWordState *wordState;</tt><br/>
			</p>
		</td>
	</tr>
</table>

<p>Some of the <tt>TDTokenizerState</tt> subclasses have methods that alter what characters are allowed within tokens of their associated token type.</p>

<p>For example, if you want to add a new multiple-character symbol like <tt>&laquo;===&raquo;</tt>:</p>

<div class="code">
<pre>
...
TDTokenizer *t = [TDTokenizerWithString:s];
[t.symbolState add:@"==="];
...</pre>
</div>

<p>Now <tt>&laquo;===&raquo;</tt> strings will be recognized as a single <tt>Symbol</tt> token with a <tt>stringValue</tt> of <tt>&laquo;===&raquo;</tt>.</p>

<p>If you don't want to allow digits within <tt>Word</tt> tokens (digits <b>are</b> allowed within <tt>Words</tt> by default):</p>

<div class="code">
<pre>
...
[t.wordState setWordChars:NO from:'0' to:'9'];
...</pre>
</div>

<p>Say you want to allow floating-point <tt>Number</tt> tokens to end with a <tt>&laquo;.&raquo;</tt> sans trailing <tt>&laquo;0&raquo;</tt>. In other words, you want <tt>&laquo;49.&raquo;</tt> to be recognized as a single <tt>Number</tt> token with a <tt>floatValue</tt> of <tt>&laquo;49.0&raquo;</tt> rather than a <tt>Number</tt> token followed by a <tt>Symbol</tt> token with a <tt>stringValue</tt> of <tt>&laquo;.&raquo;</tt>:</p>

<div class="code">
<pre>
...
t.numberState.allowsTrailingDot = YES;
...</pre>
</div>


<p>You can also configure which characters are recognized as whitespace within a whitespace token:</p>

<div class="code">
<pre>
...
[t.whitespaceState setWhitespaceChars:YES from:'0' to:'9'];
...</pre>
</div>


<h4>Changing which token type is created for a given start character</h4>

<p><tt>TDTokenizer</tt> controls the logic for deciding which token type should be created for a given start character. So to change which type is created for a given start character, you must call a method of the <tt>TDTokenizer</tt> object itself: <tt>-setTokenizerState:from:to:</tt>.</p>

<table border="1" cellpadding="5" cellspacing="0">
	<tr>
		<th><tt>TDTokenizer</tt></th>
	</tr>
	<tr>
		<td>
			<p>
				<tt>...</tt>
				<pre>- (void)setTokenizerState:(TDTokenizerState *)state 
                     from:(NSInteger)start 
                       to:(NSInteger)end;</pre>
				<tt>...</tt><br/>
			</p>
		</td>
	</tr>
</table>

<p>For example, suppose you want to turn off support for <tt>Number</tt> tokens altogether. Instead, you'd like digits to be recognized as signaling the start of <tt>Word</tt> tokens:</p>

<div class="code">
<pre>
...
TDTokenizer *t = [TDTokenizerWithString:s];
[t setTokenizerState:t.wordState from:'0' to:'9'];
...</pre>
</div>

<p>This will cause <tt>TDTokenizer</tt> to begin creating a <tt>Word</tt> token whenever a digit (<tt>&laquo;0&raquo;</tt>, <tt>&laquo;1&raquo;</tt>, <tt>&laquo;2&raquo;</tt>, <tt>&laquo;3&raquo;</tt>,<tt>&laquo;4&raquo;</tt>, <tt>&laquo;5&raquo;</tt>, <tt>&laquo;6&raquo;</tt>, <tt>&laquo;7&raquo;</tt>, <tt>&laquo;8&raquo;</tt>, <tt>&laquo;9&raquo;</tt>, <tt>&laquo;0&raquo;</tt> ) is encountered rather than a <tt>Number</tt> token. </p>

<p>As another example, say you want to add support for new <tt>Quoted String</tt> token delimiters, such as <tt>&laquo;#&raquo;</tt>. This would cause a string like <tt>#oh hai#</tt> to be recognized as a <tt>Quoted String </tt> token rather than a <tt>Symbol</tt>, two <tt>Word</tt>s, and a <tt>Symbol</tt>. Here's how:</p>

<div class="code">
<pre>
...
[t setTokenizerState:t.quoteState from:'#' to:'#'];
...</pre>
</div>

<p>Alternatively, say you want to recognize <tt>&laquo;+&raquo;</tt> characters followed immediately by digits as explicitly positive <tt>Number</tt> tokens rather than as a <tt>Symbol</tt> token followed by a <tt>Number</tt> token:</p>

<div class="code">
<pre>
...
[t setTokenizerState:t.numberState from:'+' to:'+'];
...</pre>
</div>

<p>As a final example, you may want to turn off comments. By default, TDTokenizer passes control to its <tt>slashState</tt> object which silently consumes the comment text found after <tt>//</tt> or between <tt>/* */</tt>. To disable recognizing comments, tell <tt>TDTokenizer</tt> to pass control to its <tt>symbolState</tt> instead of it's <tt>slashState</tt>.</p>

<div class="code">
<pre>
...
[t setTokenizerState:t.symbolState from:'/' to:'/'];
...</pre>
</div>

<p>Now <tt>TDTokenizer</tt> will return <tt>Symbol</tt> tokens for <tt>&laquo;/&raquo;</tt> characters.</p>


</div>
</body>
</html>